function sourceDnD() {
    var clock = document.getElementById("clock"),
        icon = new Image();
    icon.src = "images/icon.png";

    // Отображает время раз в минуту
    function displayTime() {
        var now = new Date(),
            hrs = now.getHours(),
            mins = now.getMinutes();
        if (mins < 10) mins = "0" + mins;
        clock.innerHTML = hrs + ":" + mins;
        setTimeout(displayTime, 60000);
    }
    displayTime();

    // Сделать часы доступными для буксировки.
    // То же самое можно сделать с помощью HTML-атрибута:
    // <span draggable="true">...
    clock.draggable = true;

    // Обработчики событий
    clock.ondragstart = function (event) {
        var event = event || window.event;

        /** @namespace event.dataTransfer */
        var dt = event.dataTransfer;

        // Сообщить браузеру, какие данные будут буксироваться.
        // Если конструктор Date() вызывается как функция, он возвращает
        // строку с полной информацией о текущем времени
        dt.setData("Text", Date() + "\n");

        // Определить ярлык, который будет служить визуальным представлением перемещаемой
        // строки, в браузерах, поддерживающих эту возможность. Без этого для визуального
        // представления браузер мог бы использовать изображение текста в часах.
        if (dt.setDragImage) dt.setDragImage(icon, 0, 0);
    }
}

/**
 * Прикладной программный интерфейс механизма буксировки весьма сложен, его реализации
 * в разных браузерах не являются полностью совместимыми. В своей основе этот пример
 * реализован правильно, но все браузеры немного отличаются друг от друга,
 * и каждый из них имеет свои уникальные особенности. В данном примере не делается
 * попыток реализовать обходные решения, характерные для отдельных браузеров.
 */
function receiverDnD() {
    // Отыскать все элементы <ul class = "dnd"> и вызвать функцию dnd() для них
    var lists = document.getElementsByTagName("ul"),
        regexp = /\bdnd\b/;
    for(var i = 0; i < lists.length; i++){
        if (regexp.test(lists[i].className)) dnd(lists[i]);
    }

    // Добавляет обработчики событий буксировки в элемент списка
    function dnd(list) {
        var original_class = list.className,        // Сохранить начальный CSS-class
            entered = 0;                            // Вход и выход за границы

        // Этот обработчик вызывается, когда буксируемый объект оказывается над списком.
        // Он проверяет, содержит ли буксируемый объект данные в поддерживаемом формате,
        // и, если этот так, отменяет событие, чтобы сообщить, что список готов
        // принять объект. В этом случае он также подсвечивает элемент-приемник,
        // чтобы показать пользователю, что он готов к приему данных.
        list.ondragenter = function (e) {
            e = e || window.event;
            var from = e.relatedTarget;

            // События dragenter  и dragleave всплывают, из-за чего сложнее определить,
            // когда следует подсвечивать элемент, а когда снимать подсветку в случаях,
            // подобных этому, где элемент <ui> содержит дочерние элементы <li>.
            // В браузерах, поддерживающих свойство relatedTarget, эту проблему можно решить.
            // В других браузерах приходится считать пары событий входа/выхода.

            // Если указатель мыши оказался над списком, переместившись из-за его пределов,
            // или он оказался над списком впервые, необходимо выполнить некоторые операции
            entered++;
            if ((from && !ischild(from, list)) || entered === 1) {
                // Вся информация о буксируемом объекте находится в объекте dataTransfer
                var dt = e.dataTransfer;

                // Объект dt.types содержит список типов, или форматов, в которых доступны
                // буксируемые данные. Спецификация HTML5 требует, чтобы свойство types имело
                // метод contains(). В некоторых браузерах это свойство является массивом
                // с методом indexOf. В IE версии 8 и ниже оно просто отсутствует.
                var types = dt.types;

                // Если информация о типах отсутствует или данные доступны в простом
                // текстовом формате, подсветить список, чтобы показать пользователю, что он
                // готов принять данные, и вернуть false, чтобы известить о том же и браузер.
                if (!types ||                                                   // IE
                    (types.contains && types.contains("text/plain")) ||         // HTML5
                    (types.indexOf && types.indexOf("text/plain")!== -1))       // Webkit
                {
                    list.className = original_class + " droppable";
                    return false;
                }
                // Если тип данных не поддерживается, мы не сможем принять их без отмены
                return;
            }
            return false;       // Если это не первое вхождение, по-прежнему готовы
        };

        // Этот обработчик вызывается в ходе буксировки объекта над списком.
        // Этот обработчик должен быть определен, и он должен возвращать false,
        // иначе сброс объектов будет невозможен.
        list.ondragover = function () {
            return false;
        };

        // Этот обработчик вызывается, когда буксируемый объект выходит за границы списка
        // или за границы одного из дочерних элементов. Если объект действительно
        // покидает границы списка (а не одного из его элементов),
        // то нужно снять подсветку списка.
        list.ondragleave = function (e) {
            e = e || window.event;
            var to = e.relatedTarget;

            // Если буксируемый объект покидает границы списка или если количество выходов
            // за границы совпадает с количеством входов, следует снять подсветку списка
            entered--;
            if ((to && ischild(to , list)) || entered <= 0) {
                list.className = original_class;
                entered = 0;
            }
            return false;
        };

        // Этот обработчик вызывается, когда происходит сброс объекта.
        // Он извлекает сброшенный текст и превращает его в новый элемент <li>
        list.ondrop = function (e) {
            e = e || window.event;

            // Получить сброшенные данные в текстовом формате.
            // "Text" - это псевданим для "text/plain".
            // IE не поддерживает "text/plain", поэтому здесь используется "Text".
            var dt = e.dataTransfer,
                text = dt.getData("Text");

            // Если был получен некоторый текст, превратить его в новый элемент
            // списка и добавить в конец.
            if (text) {
                var item = document.createElement("li");
                item.draggable = true;
                item.appendChild(document.createTextNode(text));
                list.appendChild(item);

                // Восстановить первоначальный стиль списка и сбросить счетчик entered
                list.className = original_class;
                entered = 0;

                return false;
            }
        };

        // Сделать все элементы списка буксируемыми
        var items = document.getElementsByTagName("li");
        for (var i = 0; i < items.length; i++){
            items[i].draggable = true;
        }

        // И зарегистрировать обработчики для поддержки буксировки элементов спмска.
        // Обработчики помещены в списки и ожидают, что события будут всплывать вверх
        // от элементов списка.

        // Этот обработчик вызывается, когда буксировка начинается внутри списка.
        list.ondragstart = function (e) {
            var e = e || window.event,
                target = e.target || e.srcElement;
            // Если всплыло событие от элемента, отличного от <li>, игнорировать его
            if (target.tagName !== "LI") return false;
            // Получить важный объект dataTransfer
            var dt = e.dataTransfer;
            // Сохранить данные и указать информацию об их формате
            dt.setData("Text", target.innerText || target.textContent);
            // Сообщить, что поддерживается операция копирования и перемещения
            dt.effectAllowed = "copyMove";
        };

        // Этот обработчик вызывается после успешного сброса
        list.ondragend = function (e) {
            var e = e || window.event,
                target = e.target || e.srcElement;

            // Если выполнялась операция перемещения, удалить элемент списка.
            // В IE это свойство будет иметь значение "none", если явно не
            // установить его в значение "move" в обработчике ondrop выше.
            // Но принудительная установка в значение "move" для IE будет
            // препятствовать другим браузерам дать пользователю вохможность
            // выбирать между операциями перемещения и копирования.
            if (e.dataTransfer.dropEffect === "move") {
                target.parentNode.removeChild(target);
            }
        };

        // Вспомогательная функция, используемая в обработчиках ondragenter и ondragleave.
        // Возвращает true, если элемент a является дочерним по отношению к элементу b.
        function ischild(a, b) {
            for (; a; a = a.parentNode){
                return a === b;
            }
        }
    }
}